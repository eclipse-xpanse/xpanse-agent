// Package xpanseclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package xpanseclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ErrorResponseErrorType.
const (
	AccessDenied                                        ErrorResponseErrorType = "Access Denied"
	AsyncRestartServiceError                            ErrorResponseErrorType = "Async Restart Service Error"
	AsyncStartServiceError                              ErrorResponseErrorType = "Async Start Service Error"
	AsyncStopServiceError                               ErrorResponseErrorType = "Async Stop Service Error"
	BillingModeNotSupported                             ErrorResponseErrorType = "Billing Mode Not Supported"
	CredentialCapabilityNotFound                        ErrorResponseErrorType = "Credential Capability Not Found"
	CredentialVariablesNotComplete                      ErrorResponseErrorType = "Credential Variables Not Complete"
	CredentialsNotFound                                 ErrorResponseErrorType = "Credentials Not Found"
	CurrentLoginUserNoFound                             ErrorResponseErrorType = "Current Login User No Found"
	DeployerNotFound                                    ErrorResponseErrorType = "Deployer Not Found"
	DeploymentFailedException                           ErrorResponseErrorType = "Deployment Failed Exception"
	DeploymentScriptsCreationFailed                     ErrorResponseErrorType = "Deployment Scripts Creation Failed"
	DeploymentVariableInvalid                           ErrorResponseErrorType = "Deployment Variable Invalid"
	DestroyFailedException                              ErrorResponseErrorType = "Destroy Failed Exception"
	DuplicatePolicy                                     ErrorResponseErrorType = "Duplicate Policy"
	EulaNotAccepted                                     ErrorResponseErrorType = "Eula Not Accepted"
	FailureWhileConnectingToBackend                     ErrorResponseErrorType = "Failure while connecting to backend"
	FileLocked                                          ErrorResponseErrorType = "File Locked"
	FlavorInvalid                                       ErrorResponseErrorType = "Flavor Invalid"
	IconProcessingFailed                                ErrorResponseErrorType = "Icon Processing Failed"
	InvalidBillingConfig                                ErrorResponseErrorType = "Invalid Billing Config"
	InvalidDeployerTool                                 ErrorResponseErrorType = "Invalid Deployer Tool"
	InvalidGitRepoDetails                               ErrorResponseErrorType = "Invalid Git Repo Details"
	InvalidServiceFlavors                               ErrorResponseErrorType = "Invalid Service Flavors"
	InvalidServiceState                                 ErrorResponseErrorType = "Invalid Service State"
	InvalidServiceVersion                               ErrorResponseErrorType = "Invalid Service Version"
	MandatoryValueMissing                               ErrorResponseErrorType = "Mandatory Value Missing"
	MetricsDataNotReady                                 ErrorResponseErrorType = "Metrics Data Not Ready"
	NoCredentialDefinitionAvailable                     ErrorResponseErrorType = "No Credential Definition Available"
	ParametersInvalid                                   ErrorResponseErrorType = "Parameters Invalid"
	PluginNotFound                                      ErrorResponseErrorType = "Plugin Not Found"
	PolicyEvaluationFailed                              ErrorResponseErrorType = "Policy Evaluation Failed"
	PolicyNotFound                                      ErrorResponseErrorType = "Policy Not Found"
	PolicyValidationFailed                              ErrorResponseErrorType = "Policy Validation Failed"
	ResourceInvalidForMonitoring                        ErrorResponseErrorType = "Resource Invalid For Monitoring"
	ResourceNotFound                                    ErrorResponseErrorType = "Resource Not Found"
	ResponseNotValid                                    ErrorResponseErrorType = "Response Not Valid"
	ReviewServiceTemplateRequestNotAllowed              ErrorResponseErrorType = "Review Service Template Request Not Allowed"
	RuntimeError                                        ErrorResponseErrorType = "Runtime Error"
	SensitiveFieldEncryptionOrDecryptionFailedException ErrorResponseErrorType = "Sensitive Field Encryption Or Decryption Failed Exception"
	ServiceActionInvalid                                ErrorResponseErrorType = "Service Action Invalid"
	ServiceConfigurationInvalid                         ErrorResponseErrorType = "Service Configuration Invalid"
	ServiceConfigurationNotFound                        ErrorResponseErrorType = "Service Configuration Not Found"
	ServiceConfigurationUpdateRequestNotFound           ErrorResponseErrorType = "Service Configuration Update Request Not Found"
	ServiceDeploymentNotFound                           ErrorResponseErrorType = "Service Deployment Not Found"
	ServiceDetailsNoAccessible                          ErrorResponseErrorType = "Service Details No Accessible"
	ServiceFlavorDowngradeNotAllowed                    ErrorResponseErrorType = "Service Flavor Downgrade Not Allowed"
	ServiceLocked                                       ErrorResponseErrorType = "Service Locked"
	ServiceOrderNotFound                                ErrorResponseErrorType = "Service Order Not Found"
	ServicePortingActivitiTaskNotFound                  ErrorResponseErrorType = "Service Porting Activiti Task Not Found"
	ServicePortingFailedException                       ErrorResponseErrorType = "Service Porting Failed Exception"
	ServicePortingNotFound                              ErrorResponseErrorType = "Service Porting Not Found"
	ServicePriceCalculationFailed                       ErrorResponseErrorType = "Service Price Calculation Failed"
	ServiceStateManagementTaskNotFound                  ErrorResponseErrorType = "Service State Management Task Not Found"
	ServiceTemplateNotRegistered                        ErrorResponseErrorType = "Service Template Not Registered"
	ServiceTemplateRequestNotAllowed                    ErrorResponseErrorType = "Service Template Request Not Allowed"
	ServiceTemplateRequestNotFound                      ErrorResponseErrorType = "Service Template Request Not Found"
	ServiceTemplateUnavailable                          ErrorResponseErrorType = "Service Template Unavailable"
	TerraBootRequestFailed                              ErrorResponseErrorType = "Terra Boot Request Failed"
	TerraformExecutionFailed                            ErrorResponseErrorType = "Terraform Execution Failed"
	TerraformScriptInvalid                              ErrorResponseErrorType = "Terraform Script Invalid"
	TofuMakerRequestFailed                              ErrorResponseErrorType = "Tofu Maker Request Failed"
	Unauthorized                                        ErrorResponseErrorType = "Unauthorized"
	UnavailableServiceRegions                           ErrorResponseErrorType = "Unavailable Service Regions"
	UnhandledException                                  ErrorResponseErrorType = "Unhandled Exception"
	UnprocessableEntity                                 ErrorResponseErrorType = "Unprocessable Entity"
	UnsupportedEnumValue                                ErrorResponseErrorType = "Unsupported Enum Value"
	VariableSchemaDefinitionInvalid                     ErrorResponseErrorType = "Variable Schema Definition Invalid"
	VariableValidationFailed                            ErrorResponseErrorType = "Variable Validation Failed"
)

// AnsibleScriptConfig defines model for AnsibleScriptConfig.
type AnsibleScriptConfig struct {
	// AnsibleInventoryRequired Defines if the complete service inventory is necessary for running the ansible job.
	AnsibleInventoryRequired *bool `json:"ansibleInventoryRequired,omitempty"`

	// Branch Branch of the git repo.
	Branch string `json:"branch"`

	// GalaxyFile Full path of the roles and collections requirements file in GIT repo.
	GalaxyFile string `json:"galaxyFile"`

	// IsPrepareAnsibleEnvironment The agent will prepare the virtual environment if this true.Otherwise it is assumed that the environment is already prepared as part of the resource creation or the VM base image build.
	IsPrepareAnsibleEnvironment bool `json:"isPrepareAnsibleEnvironment"`

	// PlaybookName name of the ansible playbook. Should be the fully qualified file name (including the directory path) in the repo.
	PlaybookName string `json:"playbookName"`

	// PythonVersion Version of the python. This version of python must be available in node which is acting as the configManager.
	PythonVersion string `json:"pythonVersion"`

	// RepoUrl Url of the script repo.
	RepoUrl string `json:"repoUrl"`

	// RequirementsFile the python module requirements file in GIT repo. Should be the fully qualified file name (including the directory path).
	RequirementsFile string `json:"requirementsFile"`

	// VirtualEnv Path where the virtualenv must be created.
	VirtualEnv string `json:"virtualEnv"`
}

// AnsibleTaskResult defines model for AnsibleTaskResult.
type AnsibleTaskResult struct {
	// IsSuccessful Depicts if the task is successful
	IsSuccessful bool `json:"isSuccessful"`

	// Message Data from the task. Will be returned both for successful and failure cases.
	Message *string `json:"message,omitempty"`

	// Name name of the Ansible task
	Name string `json:"name"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Details Details of the errors occurred
	Details []string `json:"details"`

	// ErrorType The result code of response.
	ErrorType ErrorResponseErrorType `json:"errorType"`
}

// ErrorResponseErrorType The result code of response.
type ErrorResponseErrorType string

// ServiceChangeRequest defines model for ServiceChangeRequest.
type ServiceChangeRequest struct {
	// AnsibleInventory Inventory information for Ansible script.
	AnsibleInventory    *map[string]interface{} `json:"ansibleInventory,omitempty"`
	AnsibleScriptConfig *AnsibleScriptConfig    `json:"ansibleScriptConfig,omitempty"`

	// ChangeId Id of the change request
	ChangeId openapi_types.UUID `json:"changeId"`

	// ServiceChangeParameters request parameters to be used to execute the change scripts. In case of Ansible, this will be used as extra vars.
	ServiceChangeParameters map[string]interface{} `json:"serviceChangeParameters"`
}

// ServiceChangeResult result of the service change request.
type ServiceChangeResult struct {
	// Error error description if the task failed.
	Error *string `json:"error,omitempty"`

	// IsSuccessful describes if the change is successfully executed.
	IsSuccessful bool `json:"isSuccessful"`

	// Tasks describes result of each Ansible task executed by the agent.
	Tasks *[]AnsibleTaskResult `json:"tasks,omitempty"`
}

// UpdateServiceChangeResultJSONRequestBody defines body for UpdateServiceChangeResult for application/json ContentType.
type UpdateServiceChangeResultJSONRequestBody = ServiceChangeResult

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetPendingServiceChangeRequest request
	GetPendingServiceChangeRequest(ctx context.Context, serviceId openapi_types.UUID, resourceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceChangeResultWithBody request with any body
	UpdateServiceChangeResultWithBody(ctx context.Context, changeId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceChangeResult(ctx context.Context, changeId openapi_types.UUID, body UpdateServiceChangeResultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetPendingServiceChangeRequest(ctx context.Context, serviceId openapi_types.UUID, resourceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPendingServiceChangeRequestRequest(c.Server, serviceId, resourceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceChangeResultWithBody(ctx context.Context, changeId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceChangeResultRequestWithBody(c.Server, changeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceChangeResult(ctx context.Context, changeId openapi_types.UUID, body UpdateServiceChangeResultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceChangeResultRequest(c.Server, changeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetPendingServiceChangeRequestRequest generates requests for GetPendingServiceChangeRequest
func NewGetPendingServiceChangeRequestRequest(server string, serviceId openapi_types.UUID, resourceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "resourceName", runtime.ParamLocationPath, resourceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent/xpanse/poll/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceChangeResultRequest calls the generic UpdateServiceChangeResult builder with application/json body
func NewUpdateServiceChangeResultRequest(server string, changeId openapi_types.UUID, body UpdateServiceChangeResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceChangeResultRequestWithBody(server, changeId, "application/json", bodyReader)
}

// NewUpdateServiceChangeResultRequestWithBody generates requests for UpdateServiceChangeResult with any type of body
func NewUpdateServiceChangeResultRequestWithBody(server string, changeId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "changeId", runtime.ParamLocationPath, changeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/agent/xpanse/update/status/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetPendingServiceChangeRequestWithResponse request
	GetPendingServiceChangeRequestWithResponse(ctx context.Context, serviceId openapi_types.UUID, resourceName string, reqEditors ...RequestEditorFn) (*GetPendingServiceChangeRequestResponse, error)

	// UpdateServiceChangeResultWithBodyWithResponse request with any body
	UpdateServiceChangeResultWithBodyWithResponse(ctx context.Context, changeId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceChangeResultResponse, error)

	UpdateServiceChangeResultWithResponse(ctx context.Context, changeId openapi_types.UUID, body UpdateServiceChangeResultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceChangeResultResponse, error)
}

type GetPendingServiceChangeRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceChangeRequest
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON408      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPendingServiceChangeRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPendingServiceChangeRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceChangeResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON408      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
	JSON502      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateServiceChangeResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceChangeResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetPendingServiceChangeRequestWithResponse request returning *GetPendingServiceChangeRequestResponse
func (c *ClientWithResponses) GetPendingServiceChangeRequestWithResponse(ctx context.Context, serviceId openapi_types.UUID, resourceName string, reqEditors ...RequestEditorFn) (*GetPendingServiceChangeRequestResponse, error) {
	rsp, err := c.GetPendingServiceChangeRequest(ctx, serviceId, resourceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPendingServiceChangeRequestResponse(rsp)
}

// UpdateServiceChangeResultWithBodyWithResponse request with arbitrary body returning *UpdateServiceChangeResultResponse
func (c *ClientWithResponses) UpdateServiceChangeResultWithBodyWithResponse(ctx context.Context, changeId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceChangeResultResponse, error) {
	rsp, err := c.UpdateServiceChangeResultWithBody(ctx, changeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceChangeResultResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceChangeResultWithResponse(ctx context.Context, changeId openapi_types.UUID, body UpdateServiceChangeResultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceChangeResultResponse, error) {
	rsp, err := c.UpdateServiceChangeResult(ctx, changeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceChangeResultResponse(rsp)
}

// ParseGetPendingServiceChangeRequestResponse parses an HTTP response from a GetPendingServiceChangeRequestWithResponse call
func ParseGetPendingServiceChangeRequestResponse(rsp *http.Response) (*GetPendingServiceChangeRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPendingServiceChangeRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceChangeRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}

// ParseUpdateServiceChangeResultResponse parses an HTTP response from a UpdateServiceChangeResultWithResponse call
func ParseUpdateServiceChangeResultResponse(rsp *http.Response) (*UpdateServiceChangeResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceChangeResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 408:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON408 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 502:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON502 = &dest

	}

	return response, nil
}
